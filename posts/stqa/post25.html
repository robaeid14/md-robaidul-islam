<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Software Testing – Part 2</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f4f4f4;
      padding: 20px;
    }
    .container {
      max-width: 900px;
      background: white;
      margin: auto;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    h1 {
      color: #007acc;
    }
    h2 {
      color: #2c3e50;
      margin-top: 30px;
      
    }

    ul, ol {
      margin-left: 20px;
      margin-bottom: 20px;
    }
    li {
      margin-bottom: 8px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0 20px 0;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px 12px;
      text-align: left;
    }
    th {
      background-color: #2c3e50;
      color: white;
    }
    .example {
      background: #ecf0f1;
      padding: 15px 20px;
      border-left: 5px solid #2980b9;
      margin-bottom: 30px;
      font-style: normal;
      color: #34495e;
    }
    .nav-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 40px;
    }
    .nav-buttons a {
      background-color: #007acc;
      color: white;
      padding: 10px 16px;
      text-decoration: none;
      border-radius: 5px;
      transition: background-color 0.3s ease;
    }
    .nav-buttons a:hover {
      background-color: #0d165c;
    }
  </style>
</head>
<body>
  <div class="container">
    <a href="../stqa.html" class="back-link">&larr; Back to Main Menu</a>
    <h1>Software Testing – Part 2</h1>

    <h2>1. Value-Based Testing</h2>
    <p>Value-Based Testing is a black-box testing technique that selects test inputs based on specific input values, particularly boundary and special values, where defects are commonly found.</p>

    <strong>Key Concepts</strong> 
    <ul>
      <li><strong>Normal Values:</strong> Typical inputs expected during normal operation.</li>
      <li><strong>Boundary Values:</strong> Inputs at or near the edges of valid input ranges.</li>
      <li><strong>Invalid Values:</strong> Inputs outside valid ranges or incorrect formats.</li>
    </ul>

    <strong>Importance of Boundary Values</strong>
    <p>Boundary values are critical because errors often occur at the edges of input domains due to improper handling.</p>

    <h3>Example: Age Input (1 to 100)</h3>
    <div class="example">
      <table>
        <thead>
          <tr>
            <th>Value Type</th>
            <th>Examples</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Normal Values</td>
            <td>25, 50, 75</td>
          </tr>
          <tr>
            <td>Boundary Values</td>
            <td>1, 100, 0 (just below lower boundary), 101 (just above upper boundary)</td>
          </tr>
          <tr>
            <td>Invalid Values</td>
            <td>-5, 150, "abc" (non-numeric input)</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h3>Advantages</h3>
    <ul>
      <li>Efficient detection of errors around input boundaries</li>
      <li>Reduces number of test cases without losing coverage</li>
      <li>Simple to understand and apply</li>
    </ul>

    

    <h2>2. Decision Table Testing</h2>
    <p>Decision Tables provide a systematic approach to capture combinations of inputs (conditions) and their expected outputs (actions). They are very useful in testing complex business rules or multiple condition scenarios.</p>

    <h3>Structure of a Decision Table</h3>
    <ul>
      <li><strong>Conditions:</strong> Inputs or factors affecting system behavior.</li>
      <li><strong>Actions:</strong> Expected system outputs or responses.</li>
      <li><strong>Rules:</strong> Each unique combination of conditions forming a test case.</li>
    </ul>

    <h3>Steps to Create a Decision Table</h3>
    <ol>
      <li>Identify all relevant input conditions and their possible values.</li>
      <li>List all unique combinations of these conditions (rules).</li>
      <li>Define expected actions for each combination.</li>
      <li>Develop test cases based on the decision table rules to ensure coverage.</li>
    </ol>

    <h3>Example: Login System</h3>
    <div class="example">
      <table>
        <thead>
          <tr>
            <th>User Registered</th>
            <th>Password Correct</th>
            <th>Expected Action</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Yes</td>
            <td>Yes</td>
            <td>Allow login</td>
          </tr>
          <tr>
            <td>Yes</td>
            <td>No</td>
            <td>Deny login, show error message</td>
          </tr>
          <tr>
            <td>No</td>
            <td>Yes</td>
            <td>Deny login, prompt user to register</td>
          </tr>
          <tr>
            <td>No</td>
            <td>No</td>
            <td>Deny login, prompt user to register</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h3>Benefits</h3>
    <ul>
      <li>Ensures thorough testing of all input combinations</li>
      <li>Helps identify missing, conflicting, or ambiguous requirements</li>
      <li>Improves communication between stakeholders</li>
    </ul>

    

    <h2>3. Syntax & State Transition Testing</h2>
    
    <h3>Syntax Testing</h3>
    <p>This technique verifies that input data complies with specified syntax or format rules, ensuring the system can properly process expected input patterns and reject invalid ones.</p>
    <ul>
      <li>Focuses on input formats such as dates, numbers, commands, or structured text.</li>
      <li>Detects errors caused by malformed or unexpected inputs.</li>
    </ul>
    <h4>Example:</h4>
    <p>Testing date input fields to accept only <code>YYYY-MM-DD</code> format, rejecting formats like <code>MM/DD/YYYY</code> or <code>DD-MM-YYYY</code>.</p>

    <h3>State Transition Testing</h3>
    <p>This technique models the system as a finite set of states and transitions triggered by events, testing how the system moves between states and handles inputs in each state.</p>
    <ul>
      <li>Focuses on validating valid and invalid transitions, state-dependent behavior, and error handling.</li>
      <li>Ideal for systems with complex workflows or protocols.</li>
    </ul>
    <h4>Example:</h4>
    <p>A user account system where the account states might be <em>Active</em>, <em>Suspended</em>, or <em>Closed</em>, with events like login attempts, suspensions, or deletions triggering transitions.</p>

    <h3>Advantages</h3>
    <ul>
      <li>Improves system reliability by testing valid and invalid state changes</li>
      <li>Helps identify defects related to unexpected inputs or improper state handling</li>
      <li>Provides clear documentation of expected system behavior under different scenarios</li>
    </ul>

    

    <h2>4. Statement & Path Testing</h2>
    <p>Statement and Path Testing are white-box techniques aimed at exercising the internal code structure to improve test thoroughness and detect logical errors.</p>

    <h3>Statement Testing</h3>
    <ul>
      <li>Goal is to execute every executable statement at least once.</li>
      <li>Ensures that no code lines are left untested, including error handling blocks.</li>
      <li>Simple but may miss some logical errors if paths are not fully tested.</li>
    </ul>
    <h4>Example:</h4>
    <p>Running test cases that execute all lines in a function, including conditional branches.</p>

    <h3>Path Testing</h3>
    <ul>
      <li>Involves testing all possible paths through a program’s control flow graph.</li>
      <li>Covers all decision points, loops, and possible sequences of execution.</li>
      <li>More comprehensive than statement testing but can be costly due to many possible paths.</li>
    </ul>
    <h4>Example:</h4>
    <p>Testing all paths through nested if-else statements and loops in a method.</p>

    <h3>Benefits</h3>
    <ul>
      <li>Detects hidden bugs in program logic</li>
      <li>Improves confidence in software correctness</li>
      <li>Identifies unreachable or dead code</li>
    </ul>

    <div class="nav-buttons">
      <a href="post24.html">← Previous</a>
      <a href="post26.html">Next →</a>
    </div>
  </div>
</body>
</html>
